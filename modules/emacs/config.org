#+TITLE: My Emacs Configuration
#+AUTHOR: Rick Daalhuizen
#+OPTIONS: num:nil

* Profiler

#+BEGIN_SRC emacs-lisp
(require 'profiler)
(profiler-start 'cpu)
#+END_SRC

* Increase GC Threshold
Reduce garbage collection during startup and normal operation

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 50 1000 1000))  ; 50MB (default is ~800KB)
(setq gc-cons-percentage 0.6)              ; Default is 0.1

;; Collect garbage when Emacs loses focus (optional)
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

* Disable Global File Watching

#+BEGIN_SRC emacs-lisp
;; Disable automatic file watching and monitoring
(global-auto-revert-mode -1)           ; Disable global auto-revert
(setq auto-revert-check-vc-info nil)   ; Don't check version control info
(setq auto-revert-avoid-polling t)     ; Use notifications instead of polling
(setq auto-revert-interval 5)          ; If polling, do it less frequently

;; Disable backup file creation (reduces file system activity)
(setq make-backup-files nil)           ; No backup files
(setq auto-save-default nil)           ; No auto-save files
(setq create-lockfiles nil)            ; No lock files

;; Disable recent files tracking (reduces file monitoring)
(setq recentf-mode nil)

;; Disable file name caching that watches directories
(setq find-file-visit-truename nil)
#+END_SRC

* Variables

#+BEGIN_SRC emacs-lisp
(defvar efs/default-font-size 140)
(defvar efs/default-variable-font-size 140)
#+END_SRC

* Startup Configuration
Configure Emacs startup behavior to provide a clean initial experience.

This section disables the default startup message and enables visual bell notification instead of audible beeps.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
(setq visible-bell t)
#+END_SRC

* Visual Appearance
Configure fonts and color themes for a pleasant editing environment.

Sets the default font at size 160 (16pt) and applies the built-in tango-dark theme for better readability in low-light conditions.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :font "Monaco" :height efs/default-font-size)

;; Set the fixed pitch face
(set-face-attribute 'fixed-pitch nil :font "Monaco" :height efs/default-font-size)

;; Set the variable pitch face
(set-face-attribute 'variable-pitch nil :font "Cantarell" :height efs/default-variable-font-size :weight 'regular)


(load-theme 'modus-vivendi-tinted t)
#+END_SRC

* Package Management
Initialize package repositories and configure use-package for streamlined package management.

This section sets up MELPA, Org mode, and GNU ELPA repositories, then ensures use-package is available for declarative package configuration.

#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")
                         ("elpa" . "https://elpa.gnu.org/packages/")))

(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-always-ensure t)
#+END_SRC

* Interface Customization
Remove unnecessary GUI elements to create a minimal, distraction-free editing environment.

Disables toolbar, tooltips, menu bar, and scrollbar while adding subtle fringe spacing for visual breathing room.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(tooltip-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(set-fringe-mode 10)

(column-number-mode)
(global-display-line-numbers-mode t)

;; Disable line numbers for some modes
(dolist (mode '(org-mode-hook
                term-mode-hook
                shell-mode-hook
	                treemacs-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+END_SRC

* Evil Mode Configuration
Enable Vim-style modal editing keybindings for familiar text manipulation workflows.

This provides the modal editing experience that ex-Vim users expect, with normal, insert, and visual modes. Evil-collection provides Evil bindings for modes that Evil doesn't cover by default.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :init
  ;; Prevent evil and evil-collection from interfering
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  :config
  (evil-mode 1))

(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+END_SRC

* Org Mode Setup
Configure Org mode with enhanced formatting and structure visualization.

Enables automatic indentation to better visualize document hierarchy and structure.

#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setq org-startup-indented t))
#+END_SRC

** Which Key

[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix.  For example, if you press =C-c= (hold control and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run.  This is very useful for learning the possible key bindings in the mode of your current buffer.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 1))
#+END_SRC

** Ivy and Counsel

[[https://oremacs.com/swiper/][Ivy]] is an excellent completion framework for Emacs.  It provides a minimal yet powerful selection menu that appears when you open files, switch buffers, and for many other tasks in Emacs.  Counsel is a customized set of commands to replace `find-file` with `counsel-find-file`, etc which provide useful commands for each of the default completion commands.

[[https://github.com/Yevgnen/ivy-rich][ivy-rich]] adds extra columns to a few of the Counsel commands to provide more information about each item.

#+BEGIN_SRC emacs-lisp

    (use-package ivy
      :diminish
      :bind (("C-s" . swiper)
             :map ivy-minibuffer-map
             ("TAB" . ivy-alt-done)
             ("C-l" . ivy-alt-done)
             ("C-j" . ivy-next-line)
             ("C-k" . ivy-previous-line)
             :map ivy-switch-buffer-map
             ("C-k" . ivy-previous-line)
             ("C-l" . ivy-done)
             ("C-d" . ivy-switch-buffer-kill)
             :map ivy-reverse-i-search-map
             ("C-k" . ivy-previous-line)
             ("C-d" . ivy-reverse-i-search-kill))
      :config
      (ivy-mode 1))

    (use-package ivy-rich
      :init
      (ivy-rich-mode 1))

    (use-package counsel
      :bind (("C-M-j" . 'counsel-switch-buffer)
             :map minibuffer-local-map
             ("C-r" . 'counsel-minibuffer-history))
      :config
      (counsel-mode 1))
#+END_SRC

* Development

** Languages

*** IDE Features with lsp-mode

**** lsp-mode

We use the excellent [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] to enable IDE-like functionality for many different programming languages via "language servers" that speak the [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]].  Before trying to set up =lsp-mode= for a particular language, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that you can learn which language servers are available and how to install them.

The =lsp-keymap-prefix= setting enables you to define a prefix for where =lsp-mode='s default keybindings will be added.  I *highly recommend* using the prefix to find out what you can do with =lsp-mode= in a buffer.

The =which-key= integration adds helpful descriptions of the various keys so you should be able to learn a lot just by pressing =C-c l= in a =lsp-mode= buffer and trying different things that you find there.

#+BEGIN_SRC emacs-lisp

  (defun efs/lsp-mode-setup ()
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (lsp-headerline-breadcrumb-mode))

	(use-package lsp-mode
     :commands (lsp lsp-deferred)
     :hook (lsp-mode . efs/lsp-mode-setup)
     :init
     (setq lsp-keymap-prefix "C-c l")
     :config
     (lsp-enable-which-key-integration t)
     ;; Performance improvements
		 ;; Disable file watching
     (setq lsp-enable-file-watchers nil)          ; Disable LSP file watchers
     (setq lsp-file-watch-threshold nil)          ; Don't watch any files
     (setq lsp-enable-folding nil)                ; Disable folding (reduces overhead)
     (setq lsp-enable-symbol-highlighting nil)    ; Disable symbol highlighting
     (setq lsp-enable-on-type-formatting nil)     ; Disable format-on-type
     (setq lsp-enable-indentation nil)            ; Use Emacs indentation
     (setq lsp-idle-delay 0.5)                    ; Delay before sending changes
     (setq lsp-completion-provider :capf)         ; Use completion-at-point
     (setq lsp-headerline-breadcrumb-enable nil)  ; Disable breadcrumbs
     (setq lsp-signature-auto-activate nil)       ; Disable signature help
     (setq lsp-signature-render-documentation nil)
     (setq lsp-eldoc-hook nil)                    ; Disable eldoc integration
     (setq lsp-modeline-code-actions-enable nil)  ; Disable modeline code actions
     (setq lsp-modeline-diagnostics-enable nil))  ; Disable modeline diagnostics

#+END_SRC

**** lsp-treemacs

[[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]] provides nice tree views for different aspects of your code like symbols in a file, references of a symbol, or diagnostic messages (errors and warnings) that are found in your code.

Try these commands with =M-x=:

- =lsp-treemacs-symbols= - Show a tree view of the symbols in the current file
- =lsp-treemacs-references= - Show a tree view for the references of the symbol under the cursor
- =lsp-treemacs-error-list= - Show a tree view for the diagnostic messages in the project

This package is built on the [[https://github.com/Alexander-Miller/treemacs][treemacs]] package which might be of some interest to you if you like to have a file browser at the left side of your screen in your editor.

#+BEGIN_SRC emacs-lisp

  (use-package lsp-treemacs
    :after lsp)

#+END_SRC

**** lsp-ivy

[[https://github.com/emacs-lsp/lsp-ivy][lsp-ivy]] integrates Ivy with =lsp-mode= to make it easy to search for things by name in your code.  When you run these commands, a prompt will appear in the minibuffer allowing you to type part of the name of a symbol in your code.  Results will be populated in the minibuffer so that you can find what you're looking for and jump to that location in the code upon selecting the result.

Try these commands with =M-x=:

- =lsp-ivy-workspace-symbol= - Search for a symbol name in the current project workspace
- =lsp-ivy-global-workspace-symbol= - Search for a symbol name in all active project workspaces

#+begin_src emacs-lisp

  (use-package lsp-ivy)

#+end_src

*** TypeScript

#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :mode ("\\.ts\\'" "\\.tsx\\'")
  :hook (typescript-mode . lsp-deferred)
  :config
  (setq typescript-indent-level 2))
#+END_SRC

*** PHP

#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :mode "\\.php\\'"
  :hook (php-mode . lsp-deferred)
  :config
  (setq php-mode-coding-style 'psr2))
#+END_SRC

*** Python

#+BEGIN_SRC emacs-lisp
;; Python configuration (using built-in python-mode)
(add-hook 'python-mode-hook 'lsp-deferred)
(setq python-indent-offset 4)
#+END_SRC

*** Lua

#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :mode "\\.lua\\'"
  :hook (lua-mode . lsp-deferred)
  :config
  (setq lua-indent-level 2))
#+END_SRC

*** JavaScript/React

#+BEGIN_SRC emacs-lisp
;; JavaScript (using built-in js-mode)
(add-hook 'js-mode-hook 'lsp-deferred)
(setq js-indent-level 2)

;; JSX with React
(use-package rjsx-mode
  :mode "\\.jsx\\'"
  :hook (rjsx-mode . lsp-deferred)
  :config
  (setq js2-basic-offset 2))
#+END_SRC

*** CSS/SASS

#+BEGIN_SRC emacs-lisp
;; CSS (using built-in css-mode)
(add-hook 'css-mode-hook 'lsp-deferred)
(setq css-indent-offset 2)

(use-package sass-mode
  :mode "\\.sass\\'"
  :hook (sass-mode . lsp-deferred))

(use-package scss-mode
  :mode "\\.scss\\'"
  :hook (scss-mode . lsp-deferred)
  :config
  (setq css-indent-offset 2))
#+END_SRC

*** HTML

#+BEGIN_SRC emacs-lisp
;; HTML (using built-in sgml-mode/html-mode)
(add-hook 'html-mode-hook 'lsp-deferred)
(setq sgml-basic-offset 2)

;; For more advanced HTML/templating, use web-mode
(use-package web-mode
  :mode ("\\.html\\'" "\\.htm\\'" "\\.xhtml\\'" "\\.tpl\\.php\\'" "\\.erb\\'" "\\.mustache\\'")
  :hook (web-mode . lsp-deferred)
  :config
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))
#+END_SRC

*** Go

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :mode "\\.go\\'"
  :hook (go-mode . lsp-deferred)
  :config
  (setq gofmt-command "goimports")
  (add-hook 'before-save-hook 'gofmt-before-save))
#+END_SRC

*** C/C++

#+BEGIN_SRC emacs-lisp
;; C/C++ (using built-in cc-mode)
(add-hook 'c-mode-hook 'lsp-deferred)
(add-hook 'c++-mode-hook 'lsp-deferred)
(setq c-default-style "linux"
      c-basic-offset 4)
#+END_SRC

** Projectile

[[https://projectile.mx/][Projectile]] is a project management library for Emacs which makes it a lot easier to navigate around code projects for various languages.  Many packages integrate with Projectile so it's a good idea to have it installed even if you don't use its commands directly.

#+BEGIN_SRC emacs-lisp
	(use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :custom
		((projectile-completion-system 'ivy)
      (projectile-enable-caching t)                        ; Cache file lists
      (projectile-file-exists-remote-cache-expire nil)     ; Don't expire remote cache
      (projectile-auto-discover nil)                       ; Don't auto-discover projects
      (projectile-track-known-projects-automatically nil)) ; Don't track automatically
    :bind-keymap
			("C-c p" . projectile-command-map)
    :init
      (when (file-directory-p "~/Code")
				(setq projectile-project-search-path '("~/Code")))
				(setq projectile-switch-project-action #'projectile-dired))
#+END_SRC

** Magit

[[https://magit.vc/](https://magit.vc/)[Magit]] is the best Git interface I've ever used. Common Git operations are easy to execute quickly using Magit's command panel system.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

;; NOTE: Make sure to configure a GitHub token before using this package!
;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
(use-package forge
  :after magit)
#+END_SRC

** Evil Collection

[[https://github.com/emacs-evil/evil-collection](https://github.com/emacs-evil/evil-collection)[evil-collection]] provides Evil keybindings for many Emacs modes, including Magit. This replaces the deprecated evil-magit package.

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+END_SRC

** Commenting

Emacs' built in commenting functionality =comment-dwim= (usually bound to =M-;=) doesn't always comment things in the way you might expect so we use [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] to provide a more familiar behavior.  I've bound it to =M-/= since other editors sometimes use this binding but you could also replace Emacs' =M-;= binding with this command.

#+BEGIN_SRC emacs-lisp

  (use-package evil-nerd-commenter
    :bind ("M-/" . evilnc-comment-or-uncomment-lines))

#+END_SRC

** Rainbow Delimiters

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] is useful in programming modes because it colorizes nested parentheses and brackets according to their nesting depth.  This makes it a lot easier to visually match parentheses in Emacs Lisp code without having to count them yourself.

#+BEGIN_SRC emacs-lisp

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

#+END_SRC

